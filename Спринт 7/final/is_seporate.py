# Одинаковые суммы
# https://contest.yandex.ru/contest/25597/run-report/117035112/

"""
-- Описание --
В функцию is_separate передаем список результатов в баллах. Сначала определяем возможно ли вообще разделить балы на 2 части, 
если нет - возвращаем False. Если сумма балов чётное число, создаем массив булевых элементов, первый из которых = True и является 
базовым случаем, остальные False. Далее в цикле для каждого раунда игры (элемента):
1) если элемент больше половины суммы, разделить невозможно, возвращаем False, выходим.
2) если элемент равен половине суммы - можем разделить множество на этот элемент и все остальные. Возвращаем True, выходим.
3) если элемент меньше половины суммы, во внутреннем цикле от половины суммы до значения текущего раунда с шагом -1 проходим
по массиву булевых элементов и заполняем отмечаем какие суммы можем собрать из элементов. Нам нужно добрать до половены суммы,
т.е. чтобы последний элемент массива стал True. Если получилось - возвращаем True, выходим.
Если ничего из вышеперечисленного не отработало - возвращакм False.

-- Доказательство --
Организовав алгоритм описанным выше образом, мы охватываем все возможные варианты деления множества.

-- Временная сложность --
В худшем случае, у нас 2 цикла - внешний размера числа раундов - n, и внутренний размера половины суммы элементов half_k.
То есть в худшем случае время работы О(n * half_k)

-- Пространственная сложность --
Помимо хранения массива элементов (раундов) n, мы создаем массив длины половины суммы элементов half_k.
То есть в общем счете О(n + half_k)

"""

from typing import List


def is_separate(games: List) -> bool:
    k = sum(games)
    # если сумма нечетная, на 2 множества не поделить
    if k % 2 != 0:  
        return False
    else:
    # если четная, создаем массив размера половины суммы
        half_k = int(k / 2)
        dp = [True] + [False] * half_k
        # проверяем кажый элемент
        for game in games:
            # если какой-то больше половины суммы, поделить нельзя
            if game > half_k:
                return False
            # если равен - делится на этот элемент и все остальные
            elif game == half_k:
                return True
            # если элемент меньше половины суммы заполняем в массиве подмножества сумм 
            else:
                for i in range(half_k, game - 1, -1):
                    dp[i] = dp[i - game] or dp[i]
                    if dp[-1]:
                        return True
    return False


def read_input() -> List:
    n = int(input())
    games = list(map(int, input().split()))
    return games


def main() -> None:
    print(is_separate(read_input()))


main()
