# Расстояние по Левенштейну
# https://contest.yandex.ru/contest/25597/run-report/117008090/

"""
-- Описание --
Расстояние Левинштейна - это минимальное количество изменений (замена символа, удаление символа, вставка символа), которое необходимо 
сделать с одной строкой, чтобы получить другую строку. Нам нужно подсчитать это минимальное количество изменений.
Будем создавать массивы длины меньшей строки (n). Нам нужно 2 массива - текущая и предыдущая строка. Текущая строка - массив чисел от 0 до n
включительно (проходить будем с 1). Далее идем циклом от 1 до m (длина большей строки) по текущему массиву. Текущую строку переставляем на 
место предыдущей, новую текущую заполняем порядковым номером элемента в строке длины m (для нулевого индекса) и нулями. Во вложенном
цикле проходим по элементам массивов и считаем стоимость операций на данный момент: для добавления - last_row[j] + 1, для удалаения - 
now_row[j - 1] + 1, изменение может быть или не быть, если элементы строк равны, то last_row[j - 1], если не равны last_row[j - 1] + 1.
В массив записываем минимальную из стоимостей. Таким образом в последнем элементе массива длинны n у нас будет расстояние Левинштейна для 
данных строк.

-- Доказательство --
Каждый элемент массива now_row представляет собой расстояние Левинштейна для строки длины m и префикса строки длины n. Таким образом
последний элемент будет расстоянием Левинштейна для строк длин n и m.

-- Временная сложность --
У нас 2 цикла, то есть время работы будет О(n * m).

-- Пространственная сложность --
Мы храним 2 массива длины меньшей строки n. Можем считать, что О(n).

"""


from typing import List, Tuple


def levinshtain_dist(s1: str, s2: str) -> int:
    n, m = len(s1), len(s2)
    # на 1ое место более короткую строку
    if n > m:
        s1, s2 = s2, s1
        n, m = m, n

    now_row = list(range(n + 1))
    for i in range(1, m + 1):
        last_row, now_row = now_row, [i] + [0] * n
        for j in range(1, n + 1):
            adding, deleting, changing = last_row[j] + 1, now_row[j - 1] + 1, last_row[j - 1]
            if s1[j - 1] != s2[i - 1]:
                changing += 1
            now_row[j] = min(adding, deleting, changing)

    return now_row[n]


def read_input() -> Tuple[str, str]:
    s1 = input()
    s2 = input()
    return s1, s2


def main() -> None:
    print(levinshtain_dist(*read_input()))


main()
