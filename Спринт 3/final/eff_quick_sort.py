# Эффективная быстрая сортировка
# https://contest.yandex.ru/contest/23815/run-report/115257257/

"""
-- Описание --
Реализована быстрая сортировка in-place. В качестве ключа сортировки использована функция, возврщающая кортеж из элементов (сравниваем 
по 1ому элементу по убыванию, по 2ому по возрастанию, по 0ому в лексикографисеком порядке). Сам алгоритм реализован с помощью рекурсии.

-- Доказательство --
В функцию передается массив данных и индексы первого и последнего элементов сортируемого участка, а также функция сортировки (удобнее
вынести в отдельную функцию, чем использовать lambda, т.к. используется неоднократно). В качестве базового случае определяем встречу 
1 и последнего индексов (пуской участок). В качестве разделителя, берем элемент из середины. Создаем указатели на начало и конец 
интервала. Пока указатели не пересеклись, двигаем левый указатель, пока не наткнемся на элемент больше разделителя, а правый, пока не
наткнемся на элемент меньше разделителя. Если в процессе левый указатель ушел за правый, значит все элементы уже в своих частях, если нет,
то можем поменять местами элементы, на которых находятся указатели и сделать шаги. Если левый и правый еще не встретились, повторяем весь
цикл. После выхода, рекурсивно передаем в функцию, 2 участка - от начала базового массива до правого указателя и от левого указателя
до конца базового массива (т.к. после пересечения и свопа мы делаем по шагу каждым указателем, левый оказывается справа от разделителя,
а правый - слева). В итоге получаем отсортированный массив.

-- Временная сложность --
Партицирование с 2 указателями занимает О(k), где k - количество элементов на участке в данном вызове функции, причем k <= n. Вызовов 
рекурсивной функции 2 * log(n). Таким образом, у нас 2 * log(n) * k, где k <= n. Можем считать, что время работы n * log(n). Кроме крайних
случаев, когда на всех уровнях нудачно выбирается разделитель и время увеличивается до n^2.

-- Пространственная сложность --
Алгоритм потребляет O(n) + 2 * O(1) памяти на хранение поступившего массива и изначального интервала, и О(1) * 4 для хранения указателей и
разделителей на каждом уровне вызова рекурсии. Всего вызово у нас в среднем log(n), в худшем случае может быть n. Итого потребление 
памяти может меняться от O(n) * log(n) до O(n^2).

"""

from typing import List, Tuple

def comporator(x_1, x_2, compare='less'):
    if compare == 'less':
        if x_1[1] != x_2[1]:
            return x_1[1] > x_2[1]
        elif x_1[2] != x_2[2]:
            return x_1[2] < x_2[2]
        else:
            return x_1[0] < x_2[0]
    elif compare == 'more':
        if x_1[1] != x_2[1]:
            return x_1[1] < x_2[1]
        elif x_1[2] != x_2[2]:
            return x_1[2] > x_2[2]
        else:
            return x_1[0] > x_2[0]
    else:
        raise ValueError("Choose compare as 'less' or 'more'") 


def effective_quick_sort(persons: List, start:int, stop:int, key=None) -> None:
    if start >= stop:
        return
       
    selector_idx = (start + stop) // 2
    selector = persons[selector_idx]
    left = start
    right = stop

    while left < right:
        while comporator(persons[left], selector, 'less'):
            left += 1
        while comporator(persons[right], selector, 'more'):
            right -= 1
        if left <= right:
            persons[left], persons[right] = persons[right], persons[left]
            left += 1
            right -= 1  

    effective_quick_sort(persons, start, right)
    effective_quick_sort(persons, left, stop)
 

def read_input() -> Tuple[str, List]:
    n = int(input())
    persons = []
    for i in range(n):
        person = input().split()
        person[1], person[2] = int(person[1]), int(person[2])
        persons.append(person)
    return n, persons


def main():
    n, persons = read_input()
    start = 0
    stop = n-1
    effective_quick_sort(persons, start, stop)
    answer = [x[0] for x in persons]
    print(*answer, sep='\n')


main()