# Поиск в сломанном массиве
# https://contest.yandex.ru/contest/23815/run-report/115165715/

"""
-- Описание --
Поиск элемента за O(log n) можно организовать бинарным поиском, но работает он только на отсортированном массиве. Наш массив, по сути, 
представляет собой две отсортированные части. Модифицируем бинарный поиск, выбирая, на каждом этапе отсоритрованную часть.
В функцию подается исходный массив и искомый элемент. Создаем 2 указателя на концы массива. Пока указатели не встретятся, выполняем
модифицированный бинарный поиск: берем средний элемент, если он - искомое число - возвращаем, иначе проверяем, отсортирована ли левая 
часть (если 1 элемент меньше последнего - то, да, т.к. ранее это был кольцевой буфер, если есть разрыв, то меньшие элементы будут после
максимального), если да, смотрим, лежит ли в ней искомый элемент. Если да - сокращаем интервал поиска до текущего участка. Если нет,
тоже сокращаем, но до противоположного текущему участку. Если же левая часть не была отсотрирована, значит, отсортирована другая часть
(разрыв может находится только в 1 месте). Проверяем, есть ли элемент там, если да, то аналогично - сокращаем зону поиска до текущей. 
Если элемента здесь нет, то он на противопролжной стороне. Середину всегда исключаем, т.к. ее проверили выше. Если ничего не нашлось, 
а индексы встретились - возвращаем -1.

-- Доказательство --
На каждом этапе, мы выбираем отсортированную половину и выполняем поиск на ней. Даже если элемента на ней нет, мы знаем, что он на другой
половине, размер которой мы можем уменьшить ещё на единицу за счет проверки середины. Новую часть мы снова делим и выбраем отсортированную
половину. Таким образом мы сокращаем интервал поиска в 2 раза на каждом шаге и находим элемент либо напрямую, либо методом исключения.

-- Временная сложность --
Алгоритм работает за O(log n) за счет сокращения итервала поиска в 2 раза на каждом шаге.

-- Пространственная сложность --
Мы храним исзодный массив размера n, целевое число (1), 3 указателя (лево, право, середина). Поиск производится по индексам, дополнительные
структуры для хранения не создаются.

"""

def broken_search(nums, target) -> int:
    left_idx = 0
    right_idx = len(nums) - 1

    while left_idx <= right_idx:
        mid_idx = (right_idx + left_idx) // 2
        if nums[mid_idx] == target:
            return mid_idx
        if nums[left_idx] <= nums[mid_idx]: # значит кусок до медианы отсортирован
            if nums[left_idx] <= target < nums[mid_idx]:
                right_idx = mid_idx - 1
            else:
                left_idx = mid_idx + 1
        else: # иначе - отсортирована другая часть - смотрим ее
            if nums[mid_idx] < target <= nums[right_idx]:
                left_idx = mid_idx + 1
            else:
                right_idx = mid_idx - 1
    return -1