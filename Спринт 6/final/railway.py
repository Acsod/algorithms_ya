# B. Железные дороги
# https://contest.yandex.ru/contest/25070/run-report/116621413/

"""
-- Описание --
Строим граф в виде списка смежности. Будем считать типы дорог - напралениями ребер, тогда задача сводится к
обнаружению или не обнаружению цикла внутри графа. Изначально считаем все узлы графа (города) непосещенными -
то есть красим в белый, для каждого города в цикле запускаем проверку - если в какой-либо город, мы попадем 
дважды, значит мы имеем цикл, то есть как минимум единожды прошли по обратнонаправленному пути, а следовательно
карта не оптимальна.

-- Доказательство --
В функции is_cycle изначально помечаем все вершины как непосещенные, затем последовательно выполняем обход
графа в глубину, начиная из каждой вершины с помощью функции graph_is_cycle, внутри которой создаем стек,
проверяем текущую вершину - если белая, красим в серый, возвращаем в стек, смотрим вершины, с которыми 
соединина исходящими ребрами текущая белая вершина - если цикла нет, они должны быть серыми (то есть мы 
здесь впервые), если оказывается, что вершина серая - обнаружен цикл, можем выходить и печатать 'NO'. Если 
мы изначально из стека вытащили серую вершину - красим ее в черный, т.к. это значит что мы уже проверили все 
ее исходящие грани и не обнаружили цикла. Если мы прошли по всем путям и не нашли цикл - возвращаем False в
is_cycle, чтобы проверить остальные узлы. Прошли всё и ничего не нашли - печатаем 'YES'.

-- Временная сложность --

Имеем N - количество городов, и N^2 - дорог. Тогда реализация DFS займет О(N + N^2) или O(N^2)

-- Пространственная сложность --
Нам передается полная матрица смежности, однако хранение мы осуществляем в виде списка смежности. Граф
занимает О(N + N^2) или O(N^2). Список хранения состояний по длине равен числу городов N. Размер стека - не 
более N. Итого можем считать, что занимаем O(N^2) памяти.

"""

from typing import List, Tuple

WHITE = 'white'
GRAY = 'gray'
BLACK = 'black'


def graph_is_cycle(start_v:int, graph:dict, colors:List) -> bool:
    stack = [start_v]
    while stack:
        v = stack.pop()
        if colors[v] == WHITE:
            colors[v] = GRAY
            stack.append(v) 
            for u in graph[v]:
                if colors[u] == WHITE:
                    stack.append(u)
                elif colors[u] == GRAY:
                    return True
        elif colors[v] == GRAY:
            colors[v] = BLACK
    return False


def is_cycle(graph:dict) -> None:
    colors = ['white'] * len(graph)
    return any(graph_is_cycle(city, graph, colors) for city in graph.keys())


def read_input() -> dict:
    n = int(input())
    graph = {i: [] for i in range(n)}
    for i in range(n-1):
        roads = [symb for symb in input()]
        for j, road in enumerate(roads, start=i+1):
            if road == 'B':
                graph[i].append(j)
            elif road == 'R':
                graph[j].append(i)
            else:
                raise('Unknown road type')
    return graph


def main():
    graph = read_input()
    print("NO" if is_cycle(graph) else "YES")


main()   
